python - 20
function:
function is a block of code that is reusable 
it helps reduce the code size where we use certain code again and again
to write a function we need a key word 'def' that defines that a funcyion is being defined
we need to write the body of the function inside the indentation of the function
if we dont want to write the body of the function we can use a key word 'pass'
pass is used as a 'placeholder' when a function or code block is defined but no logic is implemented yet, to avoid syntax errors.
Real-world scenario: While working in a team, one developer might define the function structure but leave the implementation for later, using pass to keep the code valid.
pass means there is nothing to exicute but the good part is that you wont get an error
this is usefull while coding in groups, one part of the code is written by one person as a function and other part can be written by some one else

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
python 21
function arguments
4 - types of arguments that we can pass to a function
defautl arguments
key word arguments 
variable length arguments
required arguments
"in a function if there are multiple return functions then the first to return is only considered then returned to the function"
If you use **args for variable-length keyword arguments, they are collected into a dictionary.
we can pass a function as an a argument to another function 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
python 22
lists:
list is a ordered collection of data items
we can modify the list after creation
there can be multiple data types in a single list
they store multiple items in one veriables
"IN PYTHON VARIABLES DOESENT STORE DATA BY THEMSELVES BUT JUST STORES THE ADDRES OF THE DATA IN THE MEMORY IT IS LIKE A POINTER TOWARDS THE DATA"
"NORMALLY WHEN WE GIVE 'A' AS A LIST AND B=A IF I ALTER EXISTING LIST 'B' BY APPENDING OR POPING 'A' WILL ALSO CHANGE"
list items are stored in "[]" square brackets, elements seperated by ',' comma
we can acces the elements of the list using index of the elements starting from 0
in python we have -ve indexing starting at the end of the list as -1 following -2 for last second element and so on
------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 23
list methods:
append(x)->         Adds an item x to the end of the list.
extend(iterable)->	Extends the list by appending all the items from the iterable.
insert(i, x)->      Inserts item x at position i.
remove(x)->         Removes the first occurrence of item x. Raises ValueError if not found.
pop([i])->      	Removes and returns the item at position i. If no index is specified, removes the last item.
clear()	->          Removes all items from the list.
index(x[, start[, end]])->	Returns the index of the first occurrence of item x. Raises ValueError if not found.
count(x)->      	Returns the number of occurrences of item x.
sort(key=None, reverse=False)->	Sorts the list in ascending order. Can be customized using key and reverse.
reverse()->     	Reverses the elements of the list in place.
copy()->        	Returns a shallow copy of the list.

"""
	in python when we create a variable and assign a value to it 
	it only points towards the memory location of the data
	if a new variable is created as = as the orignal 
	variable it also points to the same address
	there is no copy is being made for the new variable 
	so if the new variable changes then tha old variable also changes
	to avoide such conflict we use copy function	
"""
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 24
tuple:
is ordered collection of data items
it can store multiple datatypes
we cannot modify the tuple after it is created
tuple elements are stored in "()"
tuple elements are accessable using index
tuple elements are iterable
if we store single element in a tuple the python  interpreter will get confused 
for a single data and it will not be considered as a tuple 
ex:	tup =(3)
	type(tup)
	this tup variable is not <class tuple > it will be <class int>
so to avoide this we need to put a comma after the single element 
ex:	tup = (3,)
	type(tup)
	this tup variable will belong to <class tup>

in tuple there is both +ve indexing and -ve indexing same as list
tuple sliceing is also same as list
	tup2 = tup1[start: end : jump step]
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 25
operations on tuple :
there is no direct way to modify the tuple
but you can indirectly modify by this method 
*you need to rewrite the entair tuple and assign all the new values
*you can us e type casting like convert the tuple into a list and modify the list and turn the list back to tuple
we can create a tuple by concatnating 2 other tuples : tup3 = tup1+tup2
count(x)->	Returns the number of times x appears in the tuple
index(x,start,end)->	Returns the index of the first occurrence of x if found between start and end. Raises ValueError if not found

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 28
f string:
it is used to string formating

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 29
docstring ,pep-8

docstrings are string literals that appears right after the defination of a class ,method,function or modules
doc strings must be written above the body of the method
to access the doc-string we needd to use the key word '__doc__'
comments vs doc string:
	comments are completely ignored by python interpreter 
	docstring they are understood by python interpreter and are used for documenting purpose

pep 8
python enhancement proposal
it is the official style guide for writing Python code
there are many file and documents that provide help to keep your code clean, consistent, and easy to collaborate on.

zen of python
it is an easter egg in python 
it is a poem that is displayed when we import this
"this" is the module name
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 30
recursion
calling a function inside of a function is called recursion
if we are writing a recursive code in python then we need to create a base case to terminate the recursion or else 
recursion error will occur due to limit in number of recursions can occur
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 31
sets
is a collection of well defined objects
repeated values doesent exist in sets 
set is un-ordered datastructure
elements are stored in "{}" 
cannot modify the elements in the set
cannot be accessed by index 
it can store multiple datatypes
an empty set is considered a dictionary 
s = {} # this is a dictionary class 
to specify it as a set we nwwd to do : s = set()
sets can be accesed in a for loop using "in" operation
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 32
set methods

set operations

add(elem)	Adds an element to the set
update(iterable)	Adds multiple elements from an iterable
remove(elem)	Removes an element; raises KeyError if not found
discard(elem)	Removes an element if it exists (no error if not)
pop()	Removes and returns an arbitrary element
clear()	Removes all elements from the set
copy()	Returns a shallow copy of the set
union(set)	`A	B`
intersection(set)	A & B	Returns intersection
difference(set)	A - B	Returns difference
symmetric_difference(set)	A ^ B	Returns symmetric difference
issubset(set)	A <= B	Checks if current set is subset
issuperset(set)	A >= B	Checks if current set is superset
isdisjoint(set)	-	True if no elements in common
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 33
dictionaries
it is a combination of key value pairs
they are ordered collection
each key kan store multiple values 
they are stored inside "{}" seperated by "comma" but key and values are seperated by ":"
they cannot be accessed by index
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 34
dictionary methods
dict.clear()	Removes all items from the dictionary
dict.copy()	Returns a shallow copy of the dictionary
dict.fromkeys(seq, val)	Creates a new dictionary with keys from seq, all set to val
dict.get(key, default)	Returns the value for key if present, else default
dict.items()	Returns a view object of (key, value) pairs
dict.keys()	Returns a view object of all keys
dict.values()	Returns a view object of all values
dict.pop(key[, default])	Removes specified key and returns the value
dict.popitem()	Removes and returns the last inserted (key, value) pair
dict.setdefault(key[, default])	Returns value of key, sets it to default if not present
dict.update(other_dict)	Updates the dictionary with key-value pairs from other_dict
dict.__contains__(key)	Returns True if key exists (same as key in dict)
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 35
loop with else
in python else statment can also be used with loops 
after execution or before execution of the loop when the condition given to the loop becomes false the else is executed
it means else block is executed only when the loop is completed or loop cannot be executed at all
when the loop is breaked in the middel of the execution then also the else block doesen't exicute
it is used with both for and while loop
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 36
exception handeling
it is the proccess of responding to errors
here we use try ,except code 
try block tries some code and then except takes the error as input or just executes the except block 
here we can specify what kind of error are we expecting from the code or just take whatever error is raised and print the same error 
The default except block (like except Exception: or except:) must always be last
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 37
finally key word
it is used while executing try except code 
finally is a block of code that executes no matter whet ,wether try block is executed or except block is executed
finallykey word is usually used in functions where we return certain values the code below the return function is not executed
if try block has return function and except block had a return function then even after returning values finally block is executed
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 38
raising custom errors
some times we want to raise an error so that further code cannot be executed 
so we use "raise error" function
this function allows us to custom built the errors
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 41
short hand if else
it is a convenient way to assign a value to a a variable based on condition 
to avoide writing syntax that is messy and big you can use short hand if else statment 
how ever it is not recommended to use in the complex logic building there we should use if else statment correctly
we can throew an exception with shorthand if else
x = value if condition else (_ for _ in ()).throw(Exception("Error"))

(_ for _ in ()) This is a generator expression that:
Loops over an empty tuple (), so it produces no values.
_ for _ in () is just a throwaway generator that yields nothing.

.throw(Exception("Error")) → What is this?
Generators in Python have a .throw() method that:
Immediately raises an exception inside the generator.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 42
enumerate function
some times while a is loop executing we need to know which iteration or which index is executing 
we can do this by using a tempraory variable iterating along with tthe loop
or
we can use enumerate function
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 43
virtual environment in python
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 44
how import function works
you can import the whole modules but you need to specify the module name in the prefix of the function of the module
you can import the specific function from the module
you can import the module as a shortform and use that as the prefix while calling the function
you can import the specific function from the module as a short form then directly use the short form function
you can import your own modules and call the variables or the functions from your whole file
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 45
if __name__ == "__main__"
when we import our module we may run into some problems like
if there is some code that is to br executed when the module is executed
function calls all will be executed as soon as we import the module in to our code
to wether the code is being executed directly from module or from the main we use ""if __name__ == "__main__" ""
we put this code in modules because when module is seperately executed the name variable will be main
when imported the name variable will be name of the module so then the module code will not execute when imported
to confirm that the code is being executed inside the main of the code
__name__ is a python builtin variable its value is determined by the control of the code here if the controll is in the module then the name is set to name of the module
if the control is in the code then the __name__ is set to main
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 46
OS module in python
os.getcwd()	Returns the current working directory.
os.chdir(path)	Changes the current working directory to the specified path.
os.listdir(path='.')	Lists files and directories in the given path.
os.mkdir(path)	Creates a single directory.
os.makedirs(path)	Creates directories recursively.
os.rmdir(path)	Removes a single directory (must be empty).
os.removedirs(path)	Removes directories recursively.
os.rename(src, dst)	Renames a file or directory.
os.remove(path)	Removes a file.
os.stat(path)	Returns metadata like size, modified time, etc.

2. Path Operations (with os.path)
Function	Description
os.path.join(path1, path2, ...)	Joins paths in a platform-independent way.
os.path.exists(path)	Checks whether the path exists.
os.path.isdir(path)	Checks whether the path is a directory.
os.path.isfile(path)	Checks whether the path is a file.
os.path.basename(path)	Gets the file or directory name from a path.
os.path.dirname(path)	Gets the directory name from a path.
os.path.abspath(path)	Returns the absolute version of a path.
os.path.getsize(path)	Returns the size of a file in bytes.
os.path.splitext(path)	Splits the path into root and extension.

3. Environment Variables
Function	Description
os.environ	A dictionary representing the user environment.
os.getenv(key, default=None)	Gets the value of an environment variable.
os.putenv(key, value)	Sets the value of an environment variable.
os.unsetenv(key)	Unsets an environment variable.

4. Process and System Info
Function	Description
os.name	Returns the name of the OS ('posix', 'nt', etc.).
os.system(command)	Executes a shell command.
os.getpid()	Returns the current process ID.
os.getppid()	Returns the parent process ID.
os.cpu_count()	Returns the number of CPUs in the system.
os.uname()	Returns system info (Unix only).

5. File Descriptor Operations
Function	Description
os.open(path, flags)	Opens a file (low-level), returns file descriptor.
os.read(fd, n)	Reads n bytes from a file descriptor.
os.write(fd, str)	Writes to a file descriptor.
os.close(fd)	Closes the file descriptor.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 48
local variable and global variable
if a variable is created in a function or a method it cannot be accessed by outside of the method this is called local variable
a variable that is created outside of a function  it can be accessed inside of the function as long as there is no variable with the same name in the function
if there exist a variable same name as the global variable inside the function if the variable is called then local variable is returned
but the global variable value doesent changed due to presence of the local variable with the same name but different value
a global variable witha the same name as the local variable are different from each other
use the "global" key word to specify that the operation performed on the variable are actually on the global variable
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 49
file handeling in python
to open a file use "open" function and it takes 2 arguments "name of the file" and "mode"
mode can be 
'r' for reading
'w' for writing
'a' for appending
if mode is not specified then the default mode is 'r'
we can read a file by specifying it to be readed as text by using 'rt' mode
if we need it to be red as binary then use 'rb' mode
to use open function the file must exist for 'r' mode and 'a' mode
if we use a file that doesent exist and we use 'w' mode then the file is created on its own
after opening and performing the operation we need to close the file with .close() method
when i open a file then can operate only once then close and open again for another operation even if the mode is same
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 50
methods of file handling
.readline() reads lines of the file one by one
.readlines() reads all the lines at once from the file 
we can use this to iterate over the text in the file
writelines("iterable object") writes the iterable elements in the file
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 51
seek and tell methods in file handeling
after oprning a file if we used seek() method like seek(9) this will decide that file will be operated from 9th charector in the text file
after that if i used read() method then the file will be reded from 10 position
tell() is used to identify the on which position the control is in
truncate() this is used to specify that file should only contain the following number of charecters
truncate(10) this means only 10 charectors should be in the filr other than that there should be no charecters
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 52
lambda functions
a lambda function is a small anonymus function without a name it defines using lambda key word and has the following syntax
function_name = lambda arguments : expression this the variable itself can be used insted a function

lambda functions usually used to make 'mini functions' for certain expressions 
difference between lambda function and normal function is that normal functions require a certain structure 
like def key word return function so to avoide we use lambda functions
lambda functions can take all the different types of arguments as a normal functions
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 53
map,filter,reduce in python

map function is used to map a set of elements into a list 
filter function filters an iteratable like list based on the condition set by the function 
reduce function should be imported from functools 
The reduce() function in Python is used to reduce a sequence of values to a single value
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 54
difference between 'is' and '=='
both are comparision operators
is compares the exact location of the object in the memory 
== compares the actual value
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 56
oop - object oriented programming
in most programming languages there are 2 types of programming 
1.procedural programming
2.object oriented programming
oop uses classes and objects to represent the real world entity
class is a tamplet or a blue print that decides what type of objects does it make
it defines the properties ,data and methods that the object of the class will have
ex:
	college admission form -----> class [tamplet (or) blue print]
	student1 ------> form with student1 information [object (or) entity]
	student2 ------> form with student2 information [object (or) entity]
	student3 ------> form with student3 information [object (or) entity]

Encapsulation in object-oriented programming (OOP) is the mechanism of bundling the data (attributes) and methods (functions) that operate on the data into a single unit, a class

another feature is inheritence this is the proccess of extending the properties of an existing class through an other class
(or)
the proccess of extending the existing solution 
(or)
the child class inheriting the parent class 

another feature is polymorphism this concept that allows objects of different classes to be treated as objects of a common type

Abstraction in Object-Oriented Programming (OOP) is the concept of hiding complex implementation details and showing only the essential features of an object or system to the user
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 57
class and objects in python

A class is created using 'class' keyword 
'self' parameter is a reference to the current instance and is used to access variables that belong to the class
Using the self parameter means you're referring to the current instance of the class.
self should not be passed as an argument when a method is called and we cannot assign value to it
self parameter is used to access the variables in the class
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 58
constructors
these are special methods in class used to create  and initialize an object 
constructor in automatically invoked when an object of a class is created 
here ve use 'self' variable which is builtin keyword
self refers to the present instance on which the object is created and operated
methods with self variable is called instance method meaning it is only associated with the following instance only 
__init__ is a special method in Python classes. It's also called a constructor.
It initializes a new object when you create an instance of a class.
__init__ method always returns none
when a constructor doesent accept any arguments from object and has only one argument'self'then the constructor is default constructor
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 59
decorators
decorators are tools that allows to modify the behavior of the fubnctions and methods
they take functions as argument and modify  the function then return the modified function which is also called as decorated function
When a function requires arguments, the decorator must be designed to accept those arguments too.
decorators are powerful tools they are able to change the purpose of the function
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 60
getters and setters
Getters and setters are methods used in object-oriented programming 
to access and modify the attributes (variables) of a class in a controlled way

without getters and setters any one can modify the attributes without any restrictions
so we need getters and setters
Clean Syntax	Looks like a simple variable: p.name
Encapsulation	You can protect and validate data
Flexibility	Add/change logic later without breaking interface
Compatibility	Keeps internal changes invisible to user code

NOTE:
	putting '_' before a variable means "protected by convension
there are 2 ways f using getters and setters 
1.to set a protected value (or) to get a protected value by calling the getter or setter function 
2.to set a protected value (or) to get a protected value by using decorators 
2nd way is prefered by most of the proffesionals

the decorators we need to use are 
@property - turns the method into a getter.
&
@name_of_getter.setter - turns method into a setter
what this does is ,it looks like you are directly changing the attributes but behind the sceans there is controled mechanism that has its own merits and demerits

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 61
inheritance

inheritence is the proccess of extending the properties of an existing class through an other class
(or)
the proccess of extending the existing solution 
(or)
the child class inheriting the parent class

child class methods cannot be acessed by parent class
types of inheritance
1.single inheritance
2.multiple inheritance
3.multilevel inheritance
4.hierarchical inheritance
5.hybread inheritance

NOTE : for every method linked to each other some how we need to use self in every method 

if the parent has arguments in the constructor 
and when we create a constructor in the child class the constructor in child class over-rides the constructor of parent class 
what this does is the child is no longer able to inherit the properties of the parent class constructor
so we use 'super()' method to call parent constructor
by this we can set parent values and child values at the same time
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 62
access moifiers
access moifiers are used to limit the access of class variables and class methods outside the class 
types of access moifiers 
1. public 
2. private 
3. protected

public 
all the variables in python are public variables by default
any instance variable in class followed by self keyword ie, self.var_name is publically accessable

--
private
private variable means it cannot be accessed by outside of the class
but there is no strict concept of private access modifier like in java
however ,a convention has been established to indicate that a method or variable should be considered private by using double under score '_' like this "__var_name"
Python uses "name mangling" (not true access restriction) for private variables. 
When you define a variable with a double underscore prefix like __x, Python internally renames it to _ClassName__x.

even though there is a conventional method for private access modifier 
there is also a method to access indirectly access the  private properties using obj._class__nameOFvar
but this controdicts the purpose of private access modifier 
this exist because Python follows the principle: “We are all consenting adults here.”
If a developer really wants to access something private, Python won’t stop them.
But name mangling discourages accidental access or collisions, especially in inheritance.

note:
obj.__dir__() returns a list of strings, each representing the names of the attributes and methods that are accessible for the object.
--
protected
protected variable means it can be accessed by outside of the class but ethically it is intended to use only inside the class and subclass
it is created bu using single underscore prefix to the variable "_variable"
it's important to note that single underscore is just a naming convention ,and it does not provide any actual protection or ristrict assess to the properties 

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 65
static methods
there are 4 types of methods a class can contain :
1. instance method
2. static method 
3. class method
4. magic methods or dunder methods

now static method doesent belong to any instance 
it doesent have self variable
insted it uses @staticmethod decorator for the following method
static methods are used to make a method that is independent of the instance and also to give the previlage of the method to the class user only
it is accessable through the obj but it is independent of the instance it can be used any time
it is similar to a method outside a class but difference is that we need to use static method for the object of the class only
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 66
instance variable vs class variable

class employee:
    def __init__(self,name):
        self.name = name
    def display(self):
        print(f"name of the employee is {self.name}")
emp1 = employee("harry")
emp1.display()# when we call this like below ,there is an argument that is passed but it looks like no argument was given
employee.display(emp1)# when we call the above this is what actually happens
emp1.display()
Here, Python automatically passes the instance (emp1) as the first argument (self) to the method.
So internally, Python is doing:
python
employee.display(emp1)

instance variables are associated with that specific instance we can access, change the variable value
class variable are associated to every instance of the class

in python whan a variable from a c;lass is called wetehr it is a class or an instance variable
the control first looks for the variable in instance dictionary ie, obj.__dict__
if it doesent find it there then it checks in class.__dict__

whenever we try to change a class variable in main it creates an instance variable same name as the class variable
so the class variable doesent change insted the instance variable is used in place of the class variable for that instance

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 69
class methods in python
a method that is bound to the class only ,not to the inctance
it is usually used to change the behaviour of the class
ex - changing the class variable

when we use @classmethod decorator above the mathod then only it becomes a class method
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python  70
class methods as alternative constructors

some times the date to be initialize for the class will not be the expected format
so if we need to initialize that type of data we sould have to convert the data to the desaired type 
they provide a clean, Pythonic way to create objects in different ways, without overloading __init__ 
(since Python doesn’t support multiple constructors like Java or C++)

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 71
dir ,__dict__, and help 

when we use dir(obj) for an object we will see all the methods ,attributes etc available in that object
this is used for object introspection meaning when we use some new objects we can use dir( to see all the methods and attributes that are available

when we use  obj.__dict__ this returns the attributes present in the class as key value pairs

help(x) this method returns help document for the user providing user the info of x like methods ,attributes,subclasses etc
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 72
super keyword
it is used to call parent method in child method in the times when we have a method in the child class with the same name as method in parent class
if no same names we dont need super because it automatically inherits parent methods
this is different when it comes to constructor you need to use super key to inherit constructor properties of the parents 
this happens if there is a constructor in the child class which will override the constructor of the parent
the parent init will help the child set the attributes

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 73
magic / dunder methods

these methods start with double underscore and ends with double underscore
these methods allow to modify the behaviour of the class

these are all the dunder methods

| **Method**                         | **Called When…**                                      | **Purpose / Usage**                                                    |
| ---------------------------------- | ----------------------------------------------------- | ---------------------------------------------------------------------- |
| **Object Lifecycle**               |                                                       |                                                                        |
| `__new__`                          | A class is instantiated (before `__init__`).          | Controls object creation (used in metaclasses, immutables like `int`). |
| `__init__`                         | Object is initialized.                                | Constructor: set up attributes.                                        |
| `__del__`                          | Object is destroyed (garbage collected).              | Destructor: cleanup resources.                                         |
| **String & Representation**        |                                                       |                                                                        |
| `__str__`                          | `str(obj)`, `print(obj)`                              | Human-readable string.                                                 |
| `__repr__`                         | `repr(obj)`, print(obj)when __str__ is not present                              | Debug/unambiguous representation (ideally recreatable).                |
| `__format__`                       | `format(obj)`, f-strings                              | Custom string formatting.                                              |
| `__bytes__`                        | `bytes(obj)`                                          | Convert to `bytes`.                                                    |
| **Comparison Operators**           |                                                       |                                                                        |
| `__eq__`                           | `obj1 == obj2`                                        | Equality.                                                              |
| `__ne__`                           | `obj1 != obj2`                                        | Inequality.                                                            |
| `__lt__`                           | `obj1 < obj2`                                         | Less than.                                                             |
| `__le__`                           | `obj1 <= obj2`                                        | Less or equal.                                                         |
| `__gt__`                           | `obj1 > obj2`                                         | Greater than.                                                          |
| `__ge__`                           | `obj1 >= obj2`                                        | Greater or equal.                                                      |
| **Arithmetic Operators**           |                                                       |                                                                        |
| `__add__`                          | `obj1 + obj2`                                         | Addition.                                                              |
| `__sub__`                          | `obj1 - obj2`                                         | Subtraction.                                                           |
| `__mul__`                          | `obj1 * obj2`                                         | Multiplication.                                                        |
| `__truediv__`                      | `obj1 / obj2`                                         | Division.                                                              |
| `__floordiv__`                     | `obj1 // obj2`                                        | Floor division.                                                        |
| `__mod__`                          | `obj1 % obj2`                                         | Modulus.                                                               |
| `__pow__`                          | `obj1 ** obj2`                                        | Exponentiation.                                                        |
| `__radd__`, `__rsub__`, etc.       | When right-hand operand doesn’t support the operator. | Reverse arithmetic (e.g., `3 + obj`).                                  |
| `__iadd__`, `__imul__`, etc.       | `obj += value`, `obj *= value`                        | In-place arithmetic.                                                   |
| **Unary Operators**                |                                                       |                                                                        |
| `__neg__`                          | `-obj`                                                | Negation.                                                              |
| `__pos__`                          | `+obj`                                                | Unary plus.                                                            |
| `__abs__`                          | `abs(obj)`                                            | Absolute value.                                                        |
| `__invert__`                       | `~obj`                                                | Bitwise NOT.                                                           |
| **Container / Sequence Protocols** |                                                       |                                                                        |
| `__len__`                          | `len(obj)`                                            | Length of container.                                                   |
| `__getitem__`                      | `obj[key]`                                            | Indexing/slicing.                                                      |
| `__setitem__`                      | `obj[key] = val`                                      | Assign to item.                                                        |
| `__delitem__`                      | `del obj[key]`                                        | Delete item.                                                           |
| `__contains__`                     | `val in obj`                                          | Membership test.                                                       |
| `__iter__`                         | `iter(obj)`                                           | Iterator for looping.                                                  |
| `__next__`                         | `next(obj)`                                           | Next item in iterator.                                                 |
| `__reversed__`                     | `reversed(obj)`                                       | Reverse iteration.                                                     |
| **Attribute Access**               |                                                       |                                                                        |
| `__getattr__`                      | Access missing attribute.                             | Define fallback for missing attributes.                                |
| `__getattribute__`                 | Access any attribute.                                 | Intercepts *all* attribute lookups (be careful!).                      |
| `__setattr__`                      | Assign attribute.                                     | Customize attribute setting.                                           |
| `__delattr__`                      | `del obj.attr`                                        | Attribute deletion.                                                    |
| `__dir__`                          | `dir(obj)`                                            | Custom attribute listing.                                              |
| **Callable & Functional**          |                                                       |                                                                        |
| `__call__`                         | `obj()`                                               | Make object callable like a function.                                  |
| `__bool__`                         | `bool(obj)`                                           | Truthiness check.                                                      |
| **Context Managers**               |                                                       |                                                                        |
| `__enter__`                        | Start of `with` block.                                | Setup resource.                                                        |
| `__exit__`                         | End of `with` block.                                  | Cleanup resource.                                                      |
| **Numeric Conversions**            |                                                       |                                                                        |
| `__int__`                          | `int(obj)`                                            | Convert to int.                                                        |
| `__float__`                        | `float(obj)`                                          | Convert to float.                                                      |
| `__complex__`                      | `complex(obj)`                                        | Convert to complex.                                                    |
| `__round__`                        | `round(obj)`                                          | Rounding.                                                              |
| `__index__`                        | When object used as index (`list[obj]`).              | Must return integer.                                                   |
| **Class Related**                  |                                                       |                                                                        |
| `__class__`                        | `obj.__class__`                                       | Class of the object.                                                   |
| `__mro__`                          | `cls.__mro__`                                         | Method Resolution Order (for inheritance).                             |
| `__instancecheck__`                | `isinstance(obj, cls)`                                | Custom instance check.                                                 |
| `__subclasscheck__`                | `issubclass(cls1, cls2)`                              | Custom subclass check.                                                 |
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 74
method overriding
overriding methods from parent class in child class 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 76
pypdf module
PyPDF (previously known as PyPDF2) is a pure-Python library for working with PDF files.
It does not require any external software (like pdftk or Adobe).
It lets you read, split, merge, rotate, watermark, and extract text from PDFs.
It’s one of the most popular Python libraries for PDF manipulation.

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 77
operator overloading 
this is used when we deal with complex numbers 
we know that python is not intelligent enough to add 2 complex numbers or 2 vectors 
so we overload the operator add by using the dunder method __add__
a.__add__(b) = a+b # this is the actual meaning of this
by using this we will overload the add operator to add 2 complex number all by it self

some of the important operator overloading methods| Operator | Method                      | Example  |
| -------- | --------------------------- | -------- |
| `+`      | `__add__(self, other)`      | `a + b`  |
| `-`      | `__sub__(self, other)`      | `a - b`  |
| `*`      | `__mul__(self, other)`      | `a * b`  |
| `/`      | `__truediv__(self, other)`  | `a / b`  |
| `//`     | `__floordiv__(self, other)` | `a // b` |
| `%`      | `__mod__(self, other)`      | `a % b`  |
| `**`     | `__pow__(self, other)`      | `a ** b` |

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 78
single inheritance
it is a type of inheritance where a child clas inherits from a single parent it is the most common type of inheritance
syntax
class childclass(parentclass):
	#class body
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 79
multiple inheritance
it is a type of inheritance where a child class inherits from multiple parent class (usually 2 parents)
method resolution order (mro) is the order in which the controll searches for a method
ex
childclass(parent_a,parent_b):
print(childclass.mro())
output :
order of searching is 
1st childclass
2nd parent_a
3rd parent_b
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 80
multilevel inheritance
it is a type of inheritance where class inherits from another derived class 
this type of inheritance helps build a heirarchy of classes where one class builds upon another leading to more specilized class
syntax :
class parentclass:
	pass
class derivedclass1(parentclass):
	pass
class derivedclass2(derivedclass1):
	pass

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 81
hybrid and hierarchical inheritance
* hierarchical inheritance it is like a tree structure 1 root and many branches 
	ex :
		single parent class multiple child class
* hybrid inheritance is combining 2 or more inheritance
	ex:
		multiple inheritance + multilevel inheritance
		
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
python 83
win 32 and SAPI(microsoft speect API)
